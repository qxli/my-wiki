---
title: "Getting Started"
layout: page
date: 2099-06-02 00:00
---

#c++
##基本知识

- [进制转化](/code::cpp::jinzhi)
- [位操作符](/code::cpp::bit)
- [内存对齐](/code::cpp::memory-align)

##数据类型
| 类型 |32位|64位|
| char | 1 | 1 |
| int | 4 | 4 |
| long | 4 | 8 |
| 指针 | 4 | 8 |
1.win64上，int=long=4 


## 类
### 类的大小
```
1.编译器会给空类隐含的添加一个字节，这样空类实例化之后就有了独一无二的地址了。所以空类的sizeof为1。
1.类的大小为类的非静态成员数据的类型大小之和，也就是说静态成员数据不作考虑。
2.普通成员函数与sizeof无关。
3.虚函数由于要维护在虚函数表，所以要占据一个指针大小，也就是4or8字节。
4.类的总大小也遵守类似class字节对齐的，调整规则。
5.子类只是共用父类的虚函数表，因此一旦父类里有虚函数，子类的虚函数将不计入sizeof大小。
```

###封装，继承，多态

- 封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。
- 在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

###友元
友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制。也就是说有两种形式的友元：

1. 友元函数：普通函数对一个访问某个类中的私有或保护成员。
2. 友元类：类A中的成员函数访问类B中的私有或保护成员。

优点：提高了程序的运行效率。缺点：破坏了类的封装性和数据的透明性。


##语法

- [结构体](/code::cpp::struct)
- [stdio](/code::cpp::stdio)

- [hash_map](/code::cpp::hash_map)

- [memset](/code::cpp::memset)

- [宏](/code::cpp::marco)

##网络编程

- [socket](/code::cpp::socket)

##STL
###erase的用法及陷阱
```cpp
//vector
std::vector<int>::iterator iter = vv.begin();
for(;iter != vv.end();) {
    if(*iter == 5){
        iter = vv.erase(iter);
    }else {
        iter++;
    }
}
//map
std::map<int, int>::iterator it = mm.begin();
for(; it != mm.end();){
    if(it->second == 5){
        mm.erase(it++);
    } else {
        it++;
    }
}
```
###vector和list区别

1. vector和数组类似，它拥有一段连续的内存空间，并且起始地址不变，因此它能非常好的支持随机存取（即使用[]操作符访问其中的元素），但由于它的内存空间是连续的，所以在中间进行插入和删除会造成内存块的拷贝（复杂度是O(n)），另外，当该数组后的内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。这些都大大影响了vector的效率。
2. list是由数据结构中的双向链表实现的，因此它的内存空间可以是不连续的。因此只能通过指针来进行数据的访问，这个特点使得它的随机存取变的非常没有效率，需要遍历中间的元素，搜索复杂度O(n)，因此它没有提供[]操作符的重载。但由于链表的特点，它可以以很好的效率支持任意地方的删除和插入。
3. vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。
list拥有一段不连续的内存空间，因此支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。

###vector 2 set
```cpp
std::set<int> fooSet( fooVec.begin(), fooVec.end() );
std::copy( fooVec.begin(), fooVec.end(), std::inserter( fooSet, fooSet.end() ) );
```


##多线程
###线程同步
####1. 互斥量
####2. 避免死锁
#####死锁的条件
可以通过小心地控制互斥量加锁的顺序来避免死锁的发生

- 互斥条件(Mutual exclusion)     ：资源不能被共享，只能由一个进程使用。
- 请求与保持条件(Hold and wait)：进程已获得了一些资源，但因请求其它资源被阻塞时，对已获得的资源保持不放。
- 不可抢占条件(No pre-emption)    ：有些系统资源是不可抢占的，当某个进程已获得这种资源后，系统不能强行收回，只能由进程使用完时自己释放。
- 循环等待条件(Circular wait)     ：若干个进程形成环形链，每个都占用对方申请的下一个资源。

#####死锁的场景

- [忘记释放锁](/code::cpp::lock)
- [单线程重复申请锁](/code::cpp::lock)
- [多线程多锁申请](/code::cpp::lock)
- [环形锁申请](/code::cpp::lock)

####3. 读写锁
####4. 条件变量

##static作用

- 隐藏  
如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。
- 保持变量内容的持久  
存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量
- 默认初始化为0  
其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00

##malloc与new的区别

- malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。 
- 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。 
- 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。 
- C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存

##智能指针
智能指针是存储指向动态分配（堆）对象指针的类, 用于生存期控制, 它能够确保自动正确的销毁动态分配的对象，防止内存泄露。

- [auto_ptr](/code::cpp::ptr)
- [unique_ptr](/code::cpp::ptr)
- [shared_ptr](/code::cpp::ptr)
- [weak_ptr](/code::cpp::ptr)

##进程间通信方式

- 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
- 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。主要作为进程间以及同一进程内不同线程之间的同步手段。
- 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
- 套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

##参考
[５分钟搞定内存字节对齐](http://blog.csdn.net/hairetz/article/details/4084088)  
[static的作用](http://www.cnblogs.com/dc10101/archive/2007/08/22/865556.html)   
[C++中的智能指针剖析](http://zheming.wang/czhong-de-zhi-neng-zhi-zhen-pou-xi.html)